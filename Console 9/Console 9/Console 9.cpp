#include <iostream>
using namespace std;

//void test() {
//	cout << "test start\n";
//	int x = 10;
//	cout << x << "\n";
//	cout << "test finish\n";
//}
//
//int main() {
//	int m = 20;
//	cout << "main start\n";
//	test(); // синхронний виклик
//	cout << m << "\n"; // 20
//	cout << "main finish\n";
//}
// --------------------------------------------------------
//int main();
//
//void test() {
//	main();
//}
//
//int main() {
//	cout << "main start\n";
//	test(); // приклад непрямої (опосередкованої) рекурсії - функція викликає саму себе, але за допомоги додаткової функції
//	cout << "main finish\n";
//}
// --------------------------------------------------------
//int main() {
//	// при повторну коді у функцію навіть якшо це рекурсивний виклик змінна не буде створюватися 
//	static int local = 0; // в кожної функції - свої власні локальні змінні! навіть якщо це декілька версій однієї і тієї самої функції!
//	cout << &local << "\n";
//	local++; // 1
//	cout << "main start\n";
//	cout << local << "\n"; // 1
//	main();
//	cout << "main finish\n";
//}
// --------------------------------------------------------
//int main() {
//	static int local = 0;
//	local++;
//	cout << local << "\n"; // 1 2 3 4 5 ...
//	main(); // при виклику функції, виділяється пам'ять для розміщення всіх інструкцій чергової версії, а також запам'ятовується адреса інструкції після повернення (умовно, це рядок номер 9)
//	cout << "end of program";
//}
// перша версія функції мейн викликає другу,
// друга - третю і тд,
// при цьому всі попередні версії продовжують існувати в пам'яті і чекають, поки відпрацює наступна версія!
// проблема: нема умови, яка б це все завершувала

// 2 золоті правила рекурсії:
// - придумати де зробити рекурсивний виклик (функція має викликати сама себе або напряму або опосередковано)
// - придумати умову яка не дозволить в черговий раз зробити рекурсивний виклик

// всі виклики, що сталися, зберігаються в окремій області пам'яті, яка називається СТЕК (stack)
//

// 2 золоті правила рекурсії:
// - придумати де зробити рекурсивний виклик (функція має викликати сама себе або напряму або опосередковано)
// - придумати умову яка не дозволить в черговий раз зробити рекурсивний виклик

// всі виклики, що сталися, зберігаються в окремій області пам'яті, яка називається СТЕК (stack)
// --------------------------------------------------------
//int main() {
//	// 3993 виклики
//	int x = 10; // 3500 кожна локальна змінна займає місце на стеку, і тому кількість рекурсивних викликів може стати менше
//	double d = 3.14; // 3200
//	int ar[100]; // 1315
//	static int local = 0;
//	local++;
//	cout << local << "\n"; // 1 2 3 4 5 ...
//	main(); // при виклику функції, виділяється пам'ять для розміщення всіх інструкцій чергової версії, а також запам'ятовується адреса інструкції після повернення (умовно, це рядок номер 9)
//	cout << "end of program";
//}
// розмір області пам'яті СТЕК - 1МБ
// один виклик функції "вартує" 262 Б приблизно
// --------------------------------------------------------
//int main() {
//	static int local = 0;
//	local--;
//	cout << local << "\n"; // 1 2 3
//	if (local < 10) { // умова рекурсивного виклику
//		main();
//		// cout << "return from another version of main!\n";
//	}
//	else {
//		// cout << "EXIT FROM RECURSION\n";
//		// exit(0);
//	}
//	// cout << "end of program\n";
//}
// --------------------------------------------------------
//int main() {
//	static int n = 10;
//
//	cout << n << "\n";
//
//	if (--n > 0)
//		main();
//}
// --------------------------------------------------------
//int main() {
//    // Локальна змінна для відліку
//    int number = 10;
//
//    // Рекурсивна логіка всередині main через вкладений блок
//    {
//        // Виводимо поточне число
//        cout << number << " ";
//
//        // Умова зупинки рекурсії: якщо число стало 1, завершуємо
//        if (number == 1) {
//            cout << endl; // Перехід на новий рядок після завершення
//            return 0;
//        }
//
//        // Зменшуємо число на 1
//        number = number - 1;
//
//        // Рекурсивно викликаємо main (імітація рекурсії через стек викликів)
//        // Використовуємо return main() для повторного виклику
//        return main();
//    }
//
//    return 0;
//}
// --------------------------------------------------------
//void diapazone(int start, int end) {
//	cout << start << "\n"; // 1 2 3 4 5
//	if (start < end)
//		diapazone(start + 1, end); // diapazone(2, 5);
//}
//
//int main() {
//	diapazone(1, 10); // 1 2 3 4 5
//}
// --------------------------------------------------------	
//void diapazone(int start, int end) {
//    cout << start << "\n";
//    if (start > end)
//        diapazone(start - 1, end); 
//}
//
//int main() {
//    diapazone(10, 1); 
//}
// --------------------------------------------------------	
#include <windows.h>
#include <io.h>
#include <bitset>
using namespace std; 

int k = 0;

void all_files(string path, string mask)
{
	string temp = path;
	temp += mask;

	_finddata_t fileinfo;

	long long shapshot_number = _findfirst(temp.c_str(), &fileinfo);
	long long success = shapshot_number;

	while (success != -1)
	{
		// если папка:
		if (fileinfo.attrib & 16 &&
			string(fileinfo.name) != "." &&
			string(fileinfo.name) != "..")
		{
			string new_path = path;
			new_path += fileinfo.name;
			new_path += "\\";
			all_files(new_path, "*.*"); // <<< recursive call
		}

		// если файл:
		else
		{
			if (string(fileinfo.name) != "." &&
				string(fileinfo.name) != "..")
			{
				bitset<32> set = fileinfo.attrib;
				cout << set << " - " << fileinfo.name << "\n";
				k++;
			}
		}

		success = _findnext(shapshot_number, &fileinfo);
	}

	_findclose(shapshot_number);
}

int main()
{
	system("title File Search");
	system("mode con cols=150 lines=50");
	setlocale(0, "");

	all_files("C:\\1\\", "*.*");

	cout << "Total files count: " << k << "\n";
}
// --------------------------------------------------------	