//----------------------------------------------------------------
#include <iostream>
#include <windows.h>
using namespace std;

//int main()
//{
//    int x = 10;
//    cout << x << "\n"; // 10 - значення
//    cout << &x << "\n"; // 0000007BEF6FF934 - операція взяття (оримання) адреси 
//    cout << (long long)&x << "\n";
//    int y = 20;
//    cout << &y << "\n";
//    cout << &main << "\n";
//    int ar[30];
//    cout << &ar << "\n";
//    cout << &cout << "\n";
//}

//----------------------------------------------------------------

//int main()
//{
//    unsigned int size;
//    cout << "Please, enter size of array ( > 0 B): ";
//    cin >> size;
//
//    // приклад створення динамічного масиву
//    // new int[50];
//
//    // оператор new виділяє пам'ять під масиви (або навіть поодинокі об'єкти) на етапі виконання програми (в рантаймі)
//    // просимо ОС видлити пам'ять під НОВИХ САЙЗ елементів типу ІНТ)
//    while (true)
//    {
//        new int[size]; // оператор повертає в результаті роботи адресу початку блоку пам'яті
//        cout << "OK!\n";
//        Sleep(100);
//    }
//}
// 
//----------------------------------------------------------------
//int main()
//{
//	unsigned int size;
//	cout << "Please, enter size of array ( > 0 B): ";
//	cin >> size;
//	// size = 50;
//
//
//	// робота з динамічною пам'яттю без покажчиків неможлива
//	// new повертає адресу (початок блоку, де буде розміщено масив)
//	// в С++ нема ніякого іншого способу або типу даних, для того щоб цю адресу зберегти - ОКРІМ ПОКАЖЧИКА!
//	int* ar = new int[size];
//	for (int i = 0; i < size; i++)
//	{
//		ar[i] = rand() % 100;
//		cout << ar[i] << ", ";
//	}
//	delete[] ar; // звільняємо пам'ять, виділену під масив, очищення пам'яті
//
//	cout << "OK!\n";
//
//	динаміка - значення вводить або користувач, або генератор випадкових чисел, або можна прочитатти з БД, файлу, мережі
//}
//----------------------------------------------------------------
//int main() {
//	unsigned int size;
//	cout << "Please, enter size of array ( > 0 B): ";
//	cin >> size;
//	// size = 50;
//
//	if (size < 5) {
//		size = 5;
//	}
//	else if (size > 1000) {
//		size = 1000;
//	}
//
//	int* ar = new int[size];
//
//	for (unsigned int i = 0; i < size; i++)
//	{
//		ar[i] = rand() % 100;
//		cout << ar[i] << ", ";
//	}
//	delete[] ar;
//	cout << "OK!\n";
//}
//----------------------------------------------------------------
//int main()
//{
//	int x = 10;
//	cout << x << "\n";
//	cout << &x << "\n";
//	int* ptr = &x; // ptr == pointer
//	// x == int
//	// &x == int*
//	// ptr = 10; // покажчик зберігає АДРЕСИ, а не звичаінй значення!
//	int y = 20;
//	ptr = &y;
//}
//покажчик - змінна, яка зберігає адресу якоїсь іншої змінної
//---------------------------------------------------------------
//int main() {
//	int x = 10;
//	// x = 15; // змінна значення напряму 
//	int * ptr = &x;
//	cout << &x << "\n";
//	cout << ptr << "\n"; // [tr == &x
//	cout << *ptr << "\n"; // *ptr == x опесередкована переадресація (розименування)
//	// суть операції розименування
//	// 1) перейти за адресою яка зберігаєтбся у покажчику
//	// 2) отримати повній доступ до кмірки пам'яті в якій зберагається значення
//	
//	// *ptr == x
//	*ptr = 15; // x = = 15; // опесередковий доступ 
//	cout << x << "\n";
//	*ptr = 25;
//	cout << x << "\n"; // 25
//	x = 57;
//	cout << *ptr << "\n"; // 57
//}
////вказівник — це змінна(або константа) типу даних, призначеного для зберігання адрес, що дозволяє опосередковано маніпулювати різними сутностями
////Покажчик - це спосіб роботи з пам'яттю.
// ----------------------------------------------------------------
//int x = 10; //
//
//void test() {
//	x = 20; // side effect!!!
//}
//
//int main()
//{
//	cout << x << "\n"; // 10
//	test(); // x = 20;
//	cout << x << "\n"; // 20
//}
// ----------------------------------------------------------------
//void test(int x) { // х - це копія ікса з мейну! не оригінал! в копії інша адреса!
//	x = 20; // х - це локальна змінна функції тест
//} // при виході з функції всі копії будуть знищені!
//// зміна значення буде стосуватися ЛИШЕ КОПІЇ !!!! оригінал залишиться без змін!
//
//int main()
//{
//	int x = 10;
//	cout << x << "\n"; // 10
//	test(x); // x = 20;
//	cout << x << "\n"; // 20
//}
// ----------------------------------------------------------------
//int test(int x) { // x - copy!!
//	x = 20;
//	return x; // result 20
//}
//
//int main()
//{
//	int x = 10; // original = 10
//	cout << x << "\n"; // 10
//	x = test(x); // x = 20;
//	cout << x << "\n"; // 20
//}
// ----------------------------------------------------------------
//void test(int* ptr) { // int* потрібен для того, щоби перехопити адресу ОРИГІНАЛА !!!
//	*ptr = 20; // x = 20;
//}
//
//int main()
//{
//	int x = 10; // original = 10
//	cout << x << "\n"; // 10
//	test(&x); // замість копії значення, можна передати в якості аргумента АДРЕСУ ОРИГІНАЛА !!!
//	cout << x << "\n"; // 20
//}
//передання аргумента як покажчика(за покажчиком) - працюємо с оригіналом!
//оригінал може бути створено в ОДНІЙ ФУНКЦІЇЇ, а змінено - В ІНШІЙ!
//----------------------------------------------------------------
//НАВІЩО ПОКАЖЧИКИ ? ? ? ? ?
//
//Основне призначення вказівника — зберігання адреси(яку повертає оператор new або функції calloc / malloc), опосередкована адресація та робота 
//з динамічною пам'яттю. Наприклад, передача масиву в функцію можлива лише за допомогою вказівника.
//----------------------------------------------------------------
//short*
//int*
//double*
//
//МШ = 8Б
//
//Розмір, який займає вказівник в оперативній пам'яті, не залежить від типу вказівника — і завжди дорівнює одному машинному слову!
//----------------------------------------------------------------